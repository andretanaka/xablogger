package xablogger

import (
	"fmt"
	"sync"

	"github.com/sirupsen/logrus"
)

var coordinatorInstance coordinator

type coordinator struct {
	mainLogger     *logrus.Logger
	defaultFields  map[string]interface{}
	transactionMap map[string]*transaction
}

type transaction struct {
	id       string
	logger   *logrus.Entry
	segments []Segment
	mux      sync.Mutex
}

// Init must be called before creating transactions. It inits all resources like the main logrus Logger, transactionMap and defaultFields fields.
// The xablogger instance can be decorated with functional options provided at this package, like LogFormat, Hooks or DefaultFields
func Init(opts ...func(*coordinator)) {
	coordinatorInstance = coordinator{}
	coordinatorInstance.mainLogger = logrus.New()
	coordinatorInstance.defaultFields = make(map[string]interface{})
	coordinatorInstance.transactionMap = make(map[string]*transaction)

	for _, opt := range opts {
		opt(&coordinatorInstance)
	}

	// sets the default audit=true field so that you can tell which log entries are for whole transactions or not
	coordinatorInstance.defaultFields["audit"] = true
}

// LogFormat sets the output format of the main logger
func LogFormat(formatter logrus.Formatter) func(*coordinator) {
	return func(x *coordinator) {
		x.mainLogger.Formatter = formatter
	}
}

// Hooks register all hooks in the xablogger mainLogger
func Hooks(hooks ...logrus.Hook) func(*coordinator) {
	return func(x *coordinator) {
		for _, hook := range hooks {
			x.mainLogger.AddHook(hook)
		}
	}
}

// DefaultFields will save the default fields that will be appended at all log entries
func DefaultFields(fields map[string]interface{}) func(*coordinator) {
	return func(x *coordinator) {
		x.defaultFields = fields
	}
}

// NewTransaction creates a new transaction inside the coordinator map. The transactionID will be used to keep all segments together.
// The function will return an error if a transactionID already is registered for another transaction
func NewTransaction(transactionID string) error {
	if _, exists := coordinatorInstance.transactionMap[transactionID]; exists {
		return fmt.Errorf("TransactionID %s already exists inside transactions map", transactionID)
	}

	tx := transaction{
		id:       transactionID,
		segments: []Segment{},
		logger:   coordinatorInstance.mainLogger.WithFields(coordinatorInstance.defaultFields),
	}

	coordinatorInstance.transactionMap[transactionID] = &tx
	return nil
}

// AppendSegment creates a new segment to a given transaction. It will generate the segment's log entry after appending it to the
// transaction. Note that the whole audit entry must be generated by calling the Flush function.
func AppendSegment(transactionID string, segment Segment) error {

	segmentEntry := coordinatorInstance.mainLogger.WithFields(coordinatorInstance.defaultFields).WithFields(map[string]interface{}{
		"segment.type": segment.Type(),
		"segment.data": segment.Fields(),
		"audit":        false,
	})

	if segment.HasFailed() {
		segmentEntry.Error()
	} else {
		segmentEntry.Info()
	}

	if _, exists := coordinatorInstance.transactionMap[transactionID]; !exists {
		return fmt.Errorf("Transaction with ID %s not found", transactionID)
	}

	transaction := coordinatorInstance.transactionMap[transactionID]
	transaction.mux.Lock()
	transaction.segments = append(transaction.segments, segment)
	transaction.mux.Unlock()
	return nil
}

// FlushTransaction ends a transaction and generates the audit trail log event.
// The function will return an error if the transactionID cannot be found
func FlushTransaction(transactionID string) error {
	if _, exists := coordinatorInstance.transactionMap[transactionID]; !exists {
		return fmt.Errorf("TransactionID %s not found", transactionID)
	}

	tx := coordinatorInstance.transactionMap[transactionID]

	if _, failed := tx.logger.Data["error"]; failed {
		tx.logger.Error()
	} else {
		tx.logger.Info()
	}

	delete(coordinatorInstance.transactionMap, transactionID)
	return nil
}
